#ifndef SHLIB
STARTUP(LIBC_PATH/arch/UARCH/src/entry.o)
ENTRY(__entry)
#endif

PHDRS {
#if defined(LOADER)
	interp PT_INTERP;
	text PT_LOAD FILEHDR PHDRS FLAGS(5);
#elif defined(DLEXE)
	interp PT_INTERP;
	text PT_LOAD FLAGS(5);
#else
	text PT_LOAD FLAGS(5);
#endif
	data PT_LOAD FLAGS(6);
#if defined(SHLIB) || defined(DLEXE)
	dynamic PT_DYNAMIC;
#endif
}

SECTIONS {
#if defined(LOADER) || defined(DLEXE)
	.interp : {
		*(.interp);
	} :interp
#endif
#ifdef LOADER
	. = 0x70004000 + SIZEOF_HEADERS;
#else
	. = 0x4000 + SIZEOF_HEADERS;
#endif
	.init : {
		*(.init);
	} :text
	
	.text : {
		*(.text .text.*);
		*(.rodata .rodata.*);
	} :text
	
#if defined(SHLIB) || defined(DLEXE)
	.rel.plt : {
		*(.rel.plt);
	}
	/* 
	 *.rel.dyn MUST FOLLOW IMMEDIATELY after .rel.plt 
	 * without alignment gap or DT_REL will be broken
	 */
	.rel.dyn : {
		*(.rel.*);
	} :text
	
	.plt : {
		*(.plt);
	} :text
	
	.dynsym : {
		*(.dynsym);
	} :text
	
	.dynstr : {
		*(.dynstr);
	} :text
#endif
	. = . + 0x4000;
	
#if defined(SHLIB) || defined(DLEXE)
	.dynamic : {
		*(.dynamic);
	} :data :dynamic
#endif
	
	.data : {
		*(.data);
		*(.data.rel*);
	} :data
	
	.got : {
		_gp = .;
		*(.got);
	} :data
	
#ifndef DLEXE
	.tdata : {
		_tdata_start = .;
		*(.tdata);
		_tdata_end = .;
	} :data
	
	.tbss : {
		_tbss_start = .;
		*(.tbss);
		_tbss_end = .;
	} :data
	
	_tls_alignment = MAX(ALIGNOF(.tdata), ALIGNOF(.tbss));
#endif
	.sbss : {
		*(.scommon);
		*(.sbss);
	}
	
	.bss : {
		*(.bss);
		*(COMMON);
	} :data
	
#if defined(SHLIB)
#elif defined(DLEXE)
	/DISCARD/ : {
		*(.comment);
	}
#else
	/DISCARD/ : {
		*(*);
	}
#endif
}
