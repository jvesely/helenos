# Copyright (c) 2012 Sean Bartell
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
# - The name of the author may not be used to endorse or promote products
#   derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# FAT filesystem script.
# Largely based on https://en.wikipedia.org/wiki/File_Allocation_Table

transform u8 = uint8;
transform u16 = uint16le;
transform u32 = uint32le;

transform fat_dir_entry(disk) = struct {
	.filename <- known_length(8);
	.extension <- known_length(3);
	.attrs <- u8;
	.flags <- u8;
	.ctime_fine <- u8;
	.ctime <- u16;
	.cdate <- u16;
	.adate <- u16;
	.permissions <- u16;
	.mtime <- u16;
	.mdate <- u16;
	.start <- u16;
	.size <- u32;
};

transform fat_table(bits, num_clusters) = switch (bits) {
	12: partial {repeat(num_clusters) { uint_le(12) }} <- bits_le;
	16: partial {repeat(num_clusters) { u16 }};
	32: partial {repeat(num_clusters) { u32 }};
};

transform fat_super(disk) = struct {
	.jump_instruction <- known_length(3);
	.oem_name <- ascii <- known_length(8);

	# DOS 2.0 BPB
	.bytes_per_sector <- u16; # must be power of two, at least 32
	.sectors_per_cluster <- u8; # must be power of two
	.num_reserved_sectors <- u16;
	.num_fats <- u8; # at least 1
	.num_root_entries <- u16; # 0 for FAT32
	.num_sectors_16 <- u16;
	.media_descriptor <- u8;
	.sectors_per_fat <- u16; # 0 for FAT32

	# DOS 3.0/3.2/3.31 BPB
	.sectors_per_track <- u16;
	.num_heads <- u16;

	# DOS 3.31 BPB
	.bpb331 <- struct {
		.ignore <- nonzero_boolean <- (.num_sectors_16);
		.num_hidden_sectors <- u32;
		.num_sectors_32 <- u32;
	};

	.num_sectors <- if (.bpb331.ignore) {
		(.num_sectors_16)
	} else {
		(.bpb331.num_sectors_32)
	};

	.first_root_sector <- (.num_reserved_sectors + .num_fats * .sectors_per_fat);
	.first_data_sector <- (.first_root_sector +
	    (.num_root_entries * 32 + .bytes_per_sector - 1) //
	    .bytes_per_sector);
	.num_clusters <- (2 + (.num_sectors - .first_data_sector) // .sectors_per_cluster);
	.bits <- if (.num_clusters < 4085) { (12) }
	    else { if (.num_clusters < 65525) { (16) } else { (32) } };

	.fats <- partial(.num_reserved_sectors * .bytes_per_sector) {
		repeat(.num_fats) {
			fat_table(.bits, .num_clusters) <-
				known_length(.sectors_per_fat * .bytes_per_sector)
		}
	} <- (disk);

	.root <- partial(.first_root_sector * .bytes_per_sector) {
		repeat(.num_root_entries) { fat_dir_entry(disk) } } <- (disk);

	.boot_signature <- (disk[510,2]); # b"\x55\xaa"; TODO: what if .bytes_per_sector < 512?
};

transform fat_filesystem = partial { fat_super(in) };

transform main = fat_filesystem;
